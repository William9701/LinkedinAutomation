=== LEETCODE #3248: Snake in Matrix ===

=== PYTHON CODE ===
def snakeInMatrix(n: int, commands: list[str]) -> int:
    # Step 1: Initialize the snake's starting position at (0, 0).
    curr_row = 0
    curr_col = 0

    # Step 2: Define movements for each direction using a dictionary.
    # This maps command strings to their corresponding change in (row, col).
    movements = {
        "UP": (-1, 0),
        "DOWN": (1, 0),
        "LEFT": (0, -1),
        "RIGHT": (0, 1)
    }

    # Step 3: Iterate through each command in the provided list.
    for command in commands:
        # Step 4: Get the change in row and column for the current command.
        # We retrieve the (delta_row, delta_col) tuple from the movements dictionary.
        delta_row, delta_col = movements[command]
        
        # Step 5: Update the snake's current position.
        # We add the delta values to the current row and column.
        curr_row += delta_row
        curr_col += delta_col
    
    # Step 6: Calculate the final 1D index from the row and column.
    # The problem specifies that the 1D index is (row * n) + col.
    final_1d_index = (curr_row * n) + curr_col
    
    # Step 7: Return the calculated final 1D index.
    return final_1d_index

=== TYPESCRIPT CODE ===
function snakeInMatrix(n: number, commands: string[]): number {
    // Step 1: Initialize the snake's starting position at (0, 0).
    let curr_row: number = 0;
    let curr_col: number = 0;

    // Step 2: Define movements for each direction using an object (map).
    // This maps command strings to their corresponding change in (row, col).
    const movements: { [key: string]: [number, number] } = {
        "UP": [-1, 0],
        "DOWN": [1, 0],
        "LEFT": [0, -1],
        "RIGHT": [0, 1]
    };

    // Step 3: Iterate through each command in the provided list.
    for (const command of commands) {
        // Step 4: Get the change in row and column for the current command.
        // We destructure the [delta_row, delta_col] array from the movements object.
        const [delta_row, delta_col] = movements[command];
        
        // Step 5: Update the snake's current position.
        // We add the delta values to the current row and column.
        curr_row += delta_row;
        curr_col += delta_col;
    }
    
    // Step 6: Calculate the final 1D index from the row and column.
    // The problem specifies that the 1D index is (row * n) + col.
    const final_1d_index: number = (curr_row * n) + curr_col;
    
    // Step 7: Return the calculated final 1D index.
    return final_1d_index;
}

=== LINKEDIN POST (EXPLANATION) ===
THE PROBLEM IN SIMPLE WORDS
Imagine you have a grid, like a chessboard, of size n by n. A little snake starts at the very first square (top-left corner). You're given a list of instructions like "move right", "move down", and your job is to figure out which square the snake ends up on after following all instructions. The square's position is given as a single number (like counting from 0, left-to-right, top-to-bottom).

LIVE WALKTHROUGH WITH EXAMPLE
Let's trace our Python code with an example: n = 3, commands = ["RIGHT", "DOWN", "RIGHT"].

Initially:
- currrow = 0
- currcol = 0
- The movements dictionary is set up, telling us how each command changes (row, col).

Step 1: Process "RIGHT"
- We look up "RIGHT" in our movements dictionary. It tells us (0, 1).
- currrow becomes 0 + 0 = 0
- currcol becomes 0 + 1 = 1
- Snake's position is now (0, 1)

Step 2: Process "DOWN"
- We look up "DOWN". It tells us (1, 0).
- currrow becomes 0 + 1 = 1
- currcol becomes 1 + 0 = 1
- Snake's position is now (1, 1)

Step 3: Process "RIGHT"
- We look up "RIGHT". It tells us (0, 1).
- currrow becomes 1 + 0 = 1
- currcol becomes 1 + 1 = 2
- Snake's position is now (1, 2)

All commands are processed! The loop finishes.
Now, we calculate the final 1D index using the formula (row  n) + col:
- (1  3) + 2 = 3 + 2 = 5.
Our function would return 5.

THE CODE BREAKDOWN
Let's connect our walkthrough to the code comments:

- In Step 1: We start by setting currrow and currcol to 0. This is crucial because the problem states the snake always begins at cell 0, which corresponds to (0,0) in our 2D grid.
- In Step 2: We create a movements dictionary (or an object in TypeScript). This is a smart way to store how each command affects the snake's position. Instead of writing multiple 'if-else if' statements for each command, we can just look up the command in this dictionary to get the exact change in row and column.
- In Step 3: We use a 'for' loop to go through each command one by one. This ensures every instruction given to the snake is processed in order.
- In Step 4 and Step 5: Inside the loop, for each command, we retrieve its corresponding row and column changes (deltarow, deltacol) from our movements dictionary. Then, we add these changes to our snake's currrow and currcol. This effectively moves the snake according to the command.
- In Step 6: After all commands are processed, the snake is at its final (currrow, currcol) position. The problem asks for the position as a single 1D index, which is calculated as (currrow * n) + currcol. This formula converts the 2D coordinates back to the flattened 1D index.
- In Step 7: Finally, we return this calculated final 1D index as our answer.

WHY THIS WORKS
This approach works because it directly simulates the snake's movement. We accurately track its position at every step, applying each command precisely. The problem guarantees the snake stays within bounds, which simplifies things, as we don't need extra code to check for edge cases like falling off the grid.
The "aha!" moment is realizing that we can just keep adding the changes to our current position without any complex checks.
In terms of efficiency:
- Time Complexity: It's O(C), where C is the number of commands. We go through each command once, making it very fast.
- Space Complexity: It's O(1). We only store a few variables (current position, the movements dictionary) no matter how many commands or how large the grid, so memory usage is minimal.

TIPS FOR BEGINNERS
1.  Representing Movement: When dealing with movement in grids, using a dictionary or map to store direction vectors (like (-1, 0) for UP) is a super common and effective pattern. It makes your code much cleaner than long if/else chains.
2.  Initialize Carefully: Always make sure your starting variables (like currrow and currcol here) are initialized correctly according to the problem's starting conditions.
3.  Understand Output Format: Sometimes you work with one data structure internally (like our (row, col) pair), but the problem expects the final answer in a different format (like the 1D index). Always double-check what needs to be returned.
4.  Direct Simulation: For problems like this, if you can directly simulate the process step-by-step, it's often the most straightforward and efficient solution!